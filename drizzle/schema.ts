import { pgTable, foreignKey, unique, text, timestamp, varchar, boolean, integer, index } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"



export const session = pgTable("session", {
	id: text().primaryKey().notNull(),
	expiresAt: timestamp("expires_at", { mode: 'string' }).notNull(),
	token: text().notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).notNull(),
	ipAddress: text("ip_address"),
	userAgent: text("user_agent"),
	userId: text("user_id").notNull(),
	impersonatedBy: text("impersonated_by"),
}, (table) => [
	foreignKey({
			columns: [table.userId],
			foreignColumns: [user.id],
			name: "session_user_id_user_id_fk"
		}).onDelete("cascade"),
	unique("session_token_unique").on(table.token),
]);

export const emailAddresses = pgTable("email_addresses", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	address: varchar({ length: 255 }).notNull(),
	domainId: varchar("domain_id", { length: 255 }).notNull(),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	userId: varchar("user_id", { length: 255 }).notNull(),
	isReceiptRuleConfigured: boolean("is_receipt_rule_configured").default(false),
	receiptRuleName: varchar("receipt_rule_name", { length: 255 }),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	webhookId: varchar("webhook_id", { length: 255 }),
	endpointId: varchar("endpoint_id", { length: 255 }),
	tenantId: varchar("tenant_id", { length: 255 }),
}, (table) => [
	unique("email_addresses_address_unique").on(table.address),
]);

export const subscriptions = pgTable("subscriptions", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	plan: varchar({ length: 255 }).notNull(),
	referenceId: varchar("reference_id", { length: 255 }).notNull(),
	stripeCustomerId: varchar("stripe_customer_id", { length: 255 }),
	stripeSubscriptionId: varchar("stripe_subscription_id", { length: 255 }),
	status: varchar({ length: 255 }).notNull(),
	periodStart: timestamp("period_start", { mode: 'string' }),
	periodEnd: timestamp("period_end", { mode: 'string' }),
	cancelAtPeriodEnd: boolean("cancel_at_period_end").default(false),
	seats: integer(),
	trialStart: timestamp("trial_start", { mode: 'string' }),
	trialEnd: timestamp("trial_end", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const verification = pgTable("verification", {
	id: text().primaryKey().notNull(),
	identifier: text().notNull(),
	value: text().notNull(),
	expiresAt: timestamp("expires_at", { mode: 'string' }).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }),
	updatedAt: timestamp("updated_at", { mode: 'string' }),
});

export const emailDomains = pgTable("email_domains", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	domain: varchar({ length: 255 }).notNull(),
	status: varchar({ length: 50 }).notNull(),
	verificationToken: varchar("verification_token", { length: 255 }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	userId: varchar("user_id", { length: 255 }).notNull(),
	canReceiveEmails: boolean("can_receive_emails").default(false),
	hasMxRecords: boolean("has_mx_records").default(false),
	domainProvider: varchar("domain_provider", { length: 100 }),
	providerConfidence: varchar("provider_confidence", { length: 20 }),
	lastDnsCheck: timestamp("last_dns_check", { mode: 'string' }),
	lastSesCheck: timestamp("last_ses_check", { mode: 'string' }),
	isCatchAllEnabled: boolean("is_catch_all_enabled").default(false),
	catchAllWebhookId: varchar("catch_all_webhook_id", { length: 255 }),
	catchAllReceiptRuleName: varchar("catch_all_receipt_rule_name", { length: 255 }),
	catchAllEndpointId: varchar("catch_all_endpoint_id", { length: 255 }),
	mailFromDomain: varchar("mail_from_domain", { length: 255 }),
	mailFromDomainStatus: varchar("mail_from_domain_status", { length: 50 }),
	mailFromDomainVerifiedAt: timestamp("mail_from_domain_verified_at", { mode: 'string' }),
	receiveDmarcEmails: boolean("receive_dmarc_emails").default(false),
	tenantId: varchar("tenant_id", { length: 255 }),
}, (table) => [
	unique("email_domains_domain_unique").on(table.domain),
]);

export const receivedEmails = pgTable("received_emails", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	messageId: varchar("message_id", { length: 255 }).notNull(),
	from: varchar({ length: 255 }).notNull(),
	to: text().notNull(),
	subject: text(),
	receivedAt: timestamp("received_at", { mode: 'string' }).notNull(),
	processedAt: timestamp("processed_at", { mode: 'string' }),
	status: varchar({ length: 50 }).notNull(),
	metadata: text(),
	userId: varchar("user_id", { length: 255 }).notNull(),
	sesEventId: varchar("ses_event_id", { length: 255 }).notNull(),
	recipient: varchar({ length: 255 }).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	isRead: boolean("is_read").default(false),
	readAt: timestamp("read_at", { mode: 'string' }),
	fromParsed: text("from_parsed"),
	toParsed: text("to_parsed"),
	ccParsed: text("cc_parsed"),
	bccParsed: text("bcc_parsed"),
	replyToParsed: text("reply_to_parsed"),
	textBody: text("text_body"),
	htmlBody: text("html_body"),
	rawEmailContent: text("raw_email_content"),
	inReplyTo: varchar("in_reply_to", { length: 255 }),
	references: text(),
	priority: varchar({ length: 50 }),
	attachments: text(),
	headers: text(),
	emailDate: timestamp("email_date", { mode: 'string' }),
});

export const webhookDeliveries = pgTable("webhook_deliveries", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	emailId: varchar("email_id", { length: 255 }),
	endpoint: varchar({ length: 500 }).notNull(),
	status: varchar({ length: 50 }).notNull(),
	attempts: integer().default(0),
	lastAttemptAt: timestamp("last_attempt_at", { mode: 'string' }),
	responseCode: integer("response_code"),
	error: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	webhookId: varchar("webhook_id", { length: 255 }).notNull(),
	payload: text(),
	responseBody: text("response_body"),
	deliveryTime: integer("delivery_time"),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const user = pgTable("user", {
	id: text().primaryKey().notNull(),
	name: text().notNull(),
	email: text().notNull(),
	emailVerified: boolean("email_verified").notNull(),
	image: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).notNull(),
	role: text(),
	banned: boolean(),
	banReason: text("ban_reason"),
	banExpires: timestamp("ban_expires", { mode: 'string' }),
	stripeCustomerId: text("stripe_customer_id"),
	webhooksToEndpointsMigrated: boolean("webhooks_to_endpoints_migrated").default(false),
	featureFlags: text("feature_flags"),
}, (table) => [
	unique("user_email_unique").on(table.email),
]);

export const account = pgTable("account", {
	id: text().primaryKey().notNull(),
	accountId: text("account_id").notNull(),
	providerId: text("provider_id").notNull(),
	userId: text("user_id").notNull(),
	accessToken: text("access_token"),
	refreshToken: text("refresh_token"),
	idToken: text("id_token"),
	accessTokenExpiresAt: timestamp("access_token_expires_at", { mode: 'string' }),
	refreshTokenExpiresAt: timestamp("refresh_token_expires_at", { mode: 'string' }),
	scope: text(),
	password: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).notNull(),
}, (table) => [
	foreignKey({
			columns: [table.userId],
			foreignColumns: [user.id],
			name: "account_user_id_user_id_fk"
		}).onDelete("cascade"),
]);

export const blockedEmails = pgTable("blocked_emails", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	emailAddress: varchar("email_address", { length: 255 }).notNull(),
	domainId: varchar("domain_id", { length: 255 }).notNull(),
	reason: text(),
	blockedBy: varchar("blocked_by", { length: 255 }).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	unique("blocked_emails_email_address_unique").on(table.emailAddress),
]);

export const userOnboarding = pgTable("user_onboarding", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	userId: varchar("user_id", { length: 255 }).notNull(),
	isCompleted: boolean("is_completed").default(false).notNull(),
	defaultEndpointCreated: boolean("default_endpoint_created").default(false).notNull(),
	completedAt: timestamp("completed_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	unique("user_onboarding_user_id_unique").on(table.userId),
]);

export const userAccounts = pgTable("user_accounts", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	userId: varchar("user_id", { length: 255 }).notNull(),
	stripeRestrictedKey: text("stripe_restricted_key"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const scheduledEmails = pgTable("scheduled_emails", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	userId: varchar("user_id", { length: 255 }).notNull(),
	scheduledAt: timestamp("scheduled_at", { mode: 'string' }).notNull(),
	timezone: varchar({ length: 50 }).default('UTC'),
	status: varchar({ length: 50 }).default('scheduled').notNull(),
	fromAddress: varchar("from_address", { length: 500 }).notNull(),
	fromDomain: varchar("from_domain", { length: 255 }).notNull(),
	toAddresses: text("to_addresses").notNull(),
	ccAddresses: text("cc_addresses"),
	bccAddresses: text("bcc_addresses"),
	replyToAddresses: text("reply_to_addresses"),
	subject: text().notNull(),
	textBody: text("text_body"),
	htmlBody: text("html_body"),
	headers: text(),
	attachments: text(),
	tags: text(),
	attempts: integer().default(0),
	maxAttempts: integer("max_attempts").default(3),
	nextRetryAt: timestamp("next_retry_at", { mode: 'string' }),
	lastError: text("last_error"),
	idempotencyKey: varchar("idempotency_key", { length: 256 }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	sentAt: timestamp("sent_at", { mode: 'string' }),
	sentEmailId: varchar("sent_email_id", { length: 255 }),
	qstashScheduleId: varchar("qstash_schedule_id", { length: 255 }),
	qstashDlqId: varchar("qstash_dlq_id", { length: 255 }),
});

export const domainDnsRecords = pgTable("domain_dns_records", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	domainId: varchar("domain_id", { length: 255 }).notNull(),
	recordType: varchar("record_type", { length: 10 }).notNull(),
	name: varchar({ length: 255 }).notNull(),
	value: text().notNull(),
	isRequired: boolean("is_required").default(true),
	isVerified: boolean("is_verified").default(false),
	lastChecked: timestamp("last_checked", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	priority: integer(),
	description: text(),
});

export const onboardingDemoEmails = pgTable("onboarding_demo_emails", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	userId: varchar("user_id", { length: 255 }).notNull(),
	emailId: varchar("email_id", { length: 255 }).notNull(),
	recipientEmail: varchar("recipient_email", { length: 255 }).notNull(),
	sentAt: timestamp("sent_at", { mode: 'string' }).defaultNow(),
	replyReceived: boolean("reply_received").default(false),
	replyFrom: varchar("reply_from", { length: 255 }),
	replySubject: varchar("reply_subject", { length: 500 }),
	replyBody: text("reply_body"),
	replyReceivedAt: timestamp("reply_received_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	messageId: varchar("message_id", { length: 255 }),
});

export const sesTenants = pgTable("ses_tenants", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	userId: varchar("user_id", { length: 255 }).notNull(),
	awsTenantId: varchar("aws_tenant_id", { length: 255 }).notNull(),
	tenantName: varchar("tenant_name", { length: 255 }).notNull(),
	status: varchar({ length: 50 }).default('active').notNull(),
	reputationPolicy: varchar("reputation_policy", { length: 20 }).default('standard').notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	unique("ses_tenants_user_id_unique").on(table.userId),
	unique("ses_tenants_aws_tenant_id_unique").on(table.awsTenantId),
]);

export const sesEvents = pgTable("ses_events", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	eventSource: varchar("event_source", { length: 100 }).notNull(),
	eventVersion: varchar("event_version", { length: 50 }).notNull(),
	messageId: varchar("message_id", { length: 255 }).notNull(),
	source: varchar({ length: 255 }).notNull(),
	destination: text().notNull(),
	subject: text(),
	timestamp: timestamp({ mode: 'string' }).notNull(),
	receiptTimestamp: timestamp("receipt_timestamp", { mode: 'string' }).notNull(),
	processingTimeMillis: integer("processing_time_millis"),
	recipients: text().notNull(),
	spamVerdict: varchar("spam_verdict", { length: 50 }),
	virusVerdict: varchar("virus_verdict", { length: 50 }),
	spfVerdict: varchar("spf_verdict", { length: 50 }),
	dkimVerdict: varchar("dkim_verdict", { length: 50 }),
	dmarcVerdict: varchar("dmarc_verdict", { length: 50 }),
	actionType: varchar("action_type", { length: 50 }),
	s3BucketName: varchar("s3_bucket_name", { length: 255 }),
	s3ObjectKey: varchar("s3_object_key", { length: 500 }),
	emailContent: text("email_content"),
	s3ContentFetched: boolean("s3_content_fetched").default(false),
	s3ContentSize: integer("s3_content_size"),
	s3Error: text("s3_error"),
	commonHeaders: text("common_headers"),
	rawSesEvent: text("raw_ses_event").notNull(),
	lambdaContext: text("lambda_context"),
	webhookPayload: text("webhook_payload"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const webhooks = pgTable("webhooks", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	name: varchar({ length: 255 }).notNull(),
	url: text().notNull(),
	secret: varchar({ length: 255 }),
	isActive: boolean("is_active").default(true),
	description: text(),
	headers: text(),
	timeout: integer().default(30),
	retryAttempts: integer("retry_attempts").default(3),
	lastUsed: timestamp("last_used", { mode: 'string' }),
	totalDeliveries: integer("total_deliveries").default(0),
	successfulDeliveries: integer("successful_deliveries").default(0),
	failedDeliveries: integer("failed_deliveries").default(0),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	userId: varchar("user_id", { length: 255 }).notNull(),
});

export const apikey = pgTable("apikey", {
	id: text().primaryKey().notNull(),
	name: text(),
	start: text(),
	prefix: text(),
	key: text().notNull(),
	userId: text("user_id").notNull(),
	refillInterval: integer("refill_interval"),
	refillAmount: integer("refill_amount"),
	lastRefillAt: timestamp("last_refill_at", { mode: 'string' }),
	enabled: boolean().default(true),
	rateLimitEnabled: boolean("rate_limit_enabled").default(true),
	rateLimitTimeWindow: integer("rate_limit_time_window").default(86400000),
	rateLimitMax: integer("rate_limit_max").default(10),
	requestCount: integer("request_count"),
	remaining: integer(),
	lastRequest: timestamp("last_request", { mode: 'string' }),
	expiresAt: timestamp("expires_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).notNull(),
	permissions: text(),
	metadata: text(),
}, (table) => [
	foreignKey({
			columns: [table.userId],
			foreignColumns: [user.id],
			name: "apikey_user_id_user_id_fk"
		}).onDelete("cascade"),
]);

export const parsedEmails = pgTable("parsed_emails", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	emailId: varchar("email_id", { length: 255 }).notNull(),
	messageId: varchar("message_id", { length: 255 }),
	fromText: text("from_text"),
	fromAddress: varchar("from_address", { length: 255 }),
	fromName: varchar("from_name", { length: 255 }),
	toText: text("to_text"),
	toAddresses: text("to_addresses"),
	ccText: text("cc_text"),
	ccAddresses: text("cc_addresses"),
	bccText: text("bcc_text"),
	bccAddresses: text("bcc_addresses"),
	replyToText: text("reply_to_text"),
	replyToAddresses: text("reply_to_addresses"),
	subject: text(),
	textBody: text("text_body"),
	htmlBody: text("html_body"),
	inReplyTo: varchar("in_reply_to", { length: 255 }),
	references: text(),
	priority: varchar({ length: 50 }),
	emailDate: timestamp("email_date", { mode: 'string' }),
	attachments: text(),
	attachmentCount: integer("attachment_count").default(0),
	hasAttachments: boolean("has_attachments").default(false),
	headers: text(),
	hasTextBody: boolean("has_text_body").default(false),
	hasHtmlBody: boolean("has_html_body").default(false),
	parseSuccess: boolean("parse_success").default(true),
	parseError: text("parse_error"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const structuredEmails = pgTable("structured_emails", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	emailId: varchar("email_id", { length: 255 }).notNull(),
	sesEventId: varchar("ses_event_id", { length: 255 }).notNull(),
	messageId: varchar("message_id", { length: 255 }),
	date: timestamp({ mode: 'string' }),
	subject: text(),
	fromData: text("from_data"),
	toData: text("to_data"),
	ccData: text("cc_data"),
	bccData: text("bcc_data"),
	replyToData: text("reply_to_data"),
	inReplyTo: varchar("in_reply_to", { length: 255 }),
	references: text(),
	textBody: text("text_body"),
	htmlBody: text("html_body"),
	rawContent: text("raw_content"),
	attachments: text(),
	headers: text(),
	priority: varchar({ length: 50 }),
	parseSuccess: boolean("parse_success").default(true),
	parseError: text("parse_error"),
	userId: varchar("user_id", { length: 255 }).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	isRead: boolean("is_read").default(false),
	readAt: timestamp("read_at", { mode: 'string' }),
	isArchived: boolean("is_archived").default(false),
	archivedAt: timestamp("archived_at", { mode: 'string' }),
	threadId: varchar("thread_id", { length: 255 }),
	threadPosition: integer("thread_position"),
}, (table) => [
	index("structured_emails_message_id_idx").using("btree", table.messageId.asc().nullsLast().op("text_ops")),
	index("structured_emails_thread_id_idx").using("btree", table.threadId.asc().nullsLast().op("text_ops")),
]);

export const sentEmails = pgTable("sent_emails", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	from: varchar({ length: 500 }).notNull(),
	fromAddress: varchar("from_address", { length: 255 }).notNull(),
	fromDomain: varchar("from_domain", { length: 255 }).notNull(),
	to: text().notNull(),
	cc: text(),
	bcc: text(),
	replyTo: text("reply_to"),
	subject: text().notNull(),
	textBody: text("text_body"),
	htmlBody: text("html_body"),
	headers: text(),
	attachments: text(),
	status: varchar({ length: 50 }).default('pending').notNull(),
	messageId: varchar("message_id", { length: 255 }),
	provider: varchar({ length: 50 }).default('ses'),
	providerResponse: text("provider_response"),
	sentAt: timestamp("sent_at", { mode: 'string' }),
	failureReason: text("failure_reason"),
	idempotencyKey: varchar("idempotency_key", { length: 256 }),
	userId: varchar("user_id", { length: 255 }).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	tags: text(),
	threadId: varchar("thread_id", { length: 255 }),
	threadPosition: integer("thread_position"),
}, (table) => [
	index("sent_emails_thread_id_idx").using("btree", table.threadId.asc().nullsLast().op("text_ops")),
]);

export const endpoints = pgTable("endpoints", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	name: varchar({ length: 255 }).notNull(),
	type: varchar({ length: 50 }).notNull(),
	config: text().notNull(),
	isActive: boolean("is_active").default(true),
	description: text(),
	userId: varchar("user_id", { length: 255 }).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	webhookFormat: varchar("webhook_format", { length: 50 }).default('inbound'),
});

export const emailGroups = pgTable("email_groups", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	endpointId: varchar("endpoint_id", { length: 255 }).notNull(),
	emailAddress: varchar("email_address", { length: 255 }).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
});

export const endpointDeliveries = pgTable("endpoint_deliveries", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	emailId: varchar("email_id", { length: 255 }),
	endpointId: varchar("endpoint_id", { length: 255 }).notNull(),
	deliveryType: varchar("delivery_type", { length: 50 }).notNull(),
	status: varchar({ length: 50 }).notNull(),
	attempts: integer().default(0),
	lastAttemptAt: timestamp("last_attempt_at", { mode: 'string' }),
	responseData: text("response_data"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const emailThreads = pgTable("email_threads", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	rootMessageId: varchar("root_message_id", { length: 255 }).notNull(),
	normalizedSubject: text("normalized_subject"),
	participantEmails: text("participant_emails"),
	messageCount: integer("message_count").default(1),
	lastMessageAt: timestamp("last_message_at", { mode: 'string' }).notNull(),
	userId: varchar("user_id", { length: 255 }).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	index("email_threads_last_message_at_idx").using("btree", table.lastMessageAt.asc().nullsLast().op("timestamp_ops")),
	index("email_threads_root_message_id_idx").using("btree", table.rootMessageId.asc().nullsLast().op("text_ops")),
	index("email_threads_user_id_idx").using("btree", table.userId.asc().nullsLast().op("text_ops")),
]);
