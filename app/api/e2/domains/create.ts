import { Elysia, t } from "elysia"
import { validateAndRateLimit } from "../lib/auth"
import { db } from "@/lib/db"
import { emailDomains, domainDnsRecords } from "@/lib/db/schema"
import { eq } from "drizzle-orm"
import { checkDomainCanReceiveEmails } from "@/lib/domains-and-dns/dns"
import { createDomainVerification, getVerifiedParentDomain } from "@/lib/db/domains"
import { initiateDomainVerification } from "@/lib/domains-and-dns/domain-verification"
import { Autumn as autumn } from "autumn-js"
import { isSubdomain } from "@/lib/domains-and-dns/domain-utils"
import { nanoid } from "nanoid"

// AWS Region for MX record
const awsRegion = process.env.AWS_REGION || "us-east-2"

// Request/Response Types (OpenAPI-compatible)
const CreateDomainBody = t.Object({
  domain: t.String({ minLength: 1, maxLength: 253 }),
})

const DnsRecordSchema = t.Object({
  type: t.String(),
  name: t.String(),
  value: t.String(),
  description: t.Optional(t.String()),
  isRequired: t.Boolean(),
})

const DnsConflictSchema = t.Object({
  hasConflict: t.Boolean(),
  conflictType: t.Optional(t.Union([t.Literal("mx"), t.Literal("cname"), t.Literal("both")])),
  message: t.String(),
  existingRecords: t.Optional(t.Array(t.Object({
    type: t.String(),
    value: t.String(),
  }))),
})

const CreateDomainResponse = t.Object({
  id: t.String(),
  domain: t.String(),
  status: t.Union([t.Literal("pending"), t.Literal("verified"), t.Literal("failed")]),
  canReceiveEmails: t.Boolean(),
  hasMxRecords: t.Boolean(),
  domainProvider: t.Nullable(t.String()),
  providerConfidence: t.Nullable(t.String()),
  mailFromDomain: t.Optional(t.String()),
  mailFromDomainStatus: t.Optional(t.String()),
  dnsRecords: t.Array(DnsRecordSchema),
  dnsConflict: t.Optional(DnsConflictSchema),
  createdAt: t.Date(),
  updatedAt: t.Date(),
  parentDomain: t.Optional(t.String()),
  message: t.Optional(t.String()),
})

const CreateDomainErrorResponse = t.Object({
  error: t.String(),
  code: t.Optional(t.String()),
})

export const createDomain = new Elysia().post(
  "/domains",
  async ({ request, body, set }) => {
    console.log("‚ûï POST /api/e2/domains - Starting domain creation")

    // Auth & rate limit validation - throws on error
    const userId = await validateAndRateLimit(request, set)
    console.log("‚úÖ Authentication successful for userId:", userId)

    console.log("üìù Request data:", { domain: body.domain })

    // Validate required fields
    if (!body.domain) {
      console.log("‚ùå Missing required field: domain")
      set.status = 400
      return { error: "Domain is required" }
    }

    // Normalize domain (lowercase, trim)
    const domain = body.domain.toLowerCase().trim()

    // Validate domain format
    const domainRegex =
      /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
    if (!domainRegex.test(domain) || domain.length > 253) {
      console.log("‚ùå Invalid domain format:", domain)
      set.status = 400
      return { error: "Invalid domain format" }
    }

    // Check if domain already exists on the platform (for any user)
    console.log("üîç Checking if domain already exists on platform")
    const existingDomainAnyUser = await db
      .select({
        id: emailDomains.id,
        userId: emailDomains.userId,
        status: emailDomains.status,
        createdAt: emailDomains.createdAt,
      })
      .from(emailDomains)
      .where(eq(emailDomains.domain, domain))
      .limit(1)

    if (existingDomainAnyUser[0]) {
      const isOwnDomain = existingDomainAnyUser[0].userId === userId

      if (isOwnDomain) {
        console.log("‚ùå Domain already exists for current user:", domain)
        set.status = 409
        return {
          error: "You have already added this domain to your account",
        }
      } else {
        console.log("‚ùå Domain already registered by another user:", domain)
        set.status = 409
        return {
          error:
            "This domain is already registered on our platform. If you believe this is an error or you need to transfer ownership, please contact our support team.",
          code: "DOMAIN_ALREADY_REGISTERED",
        }
      }
    }

    // Check Autumn domain limits
    console.log("üîç Checking domain limits with Autumn")
    const { data: domainCheck, error: domainCheckError } = await autumn.check({
      customer_id: userId,
      feature_id: "domains",
    })

    if (domainCheckError) {
      console.error("‚ùå Autumn domain check error:", domainCheckError)
      set.status = 500
      return { error: "Failed to check domain limits" }
    }

    if (!domainCheck?.allowed) {
      console.log("‚ùå Domain limit reached for user:", userId)
      set.status = 403
      return {
        error: "Domain limit reached. Please upgrade your plan to add more domains.",
      }
    }

    console.log("‚úÖ Domain limits check passed:", {
      allowed: domainCheck.allowed,
      balance: domainCheck.balance,
      unlimited: domainCheck.unlimited,
    })

    // Check DNS for conflicts (MX/CNAME records) - non-blocking
    console.log("üîç Checking DNS records for conflicts")
    const dnsResult = await checkDomainCanReceiveEmails(domain)

    // Build DNS conflict info if there are conflicts (but don't block)
    let dnsConflict: {
      hasConflict: boolean
      conflictType?: "mx" | "cname" | "both"
      message: string
      existingRecords?: Array<{ type: string; value: string }>
    } | undefined

    if (!dnsResult.canReceiveEmails) {
      console.log("‚ö†Ô∏è DNS conflict detected (non-blocking):", dnsResult.error)
      
      // Determine conflict type and build existing records list
      const existingRecords: Array<{ type: string; value: string }> = []
      let conflictType: "mx" | "cname" | "both" | undefined
      
      if (dnsResult.hasMxRecords && dnsResult.mxRecords && dnsResult.mxRecords.length > 0) {
        for (const mx of dnsResult.mxRecords) {
          existingRecords.push({
            type: "MX",
            value: `${mx.priority} ${mx.exchange}`,
          })
        }
        conflictType = "mx"
      }
      
      // Check if error mentions CNAME
      if (dnsResult.error?.toLowerCase().includes("cname")) {
        conflictType = conflictType === "mx" ? "both" : "cname"
      }
      
      dnsConflict = {
        hasConflict: true,
        conflictType,
        message: dnsResult.error || "Domain has existing DNS records that may conflict with email receiving. You'll need to update these records.",
        existingRecords: existingRecords.length > 0 ? existingRecords : undefined,
      }
    } else {
      console.log("‚úÖ DNS check passed:", {
        canReceiveEmails: dnsResult.canReceiveEmails,
        hasMxRecords: dnsResult.hasMxRecords,
        provider: dnsResult.provider?.name,
      })
    }

    // Create domain record in database
    console.log("üíæ Creating domain record in database")
    const domainRecord = await createDomainVerification(domain, userId, {
      canReceiveEmails: dnsResult.canReceiveEmails,
      hasMxRecords: dnsResult.hasMxRecords,
      provider: dnsResult.provider,
    })

    // Check if this is a subdomain with verified parent
    let parentDomain: string | null = null
    if (isSubdomain(domain)) {
      const parent = await getVerifiedParentDomain(domain, userId)
      if (parent) {
        console.log(`‚úÖ Subdomain detected with verified parent: ${parent.domain}`)
        parentDomain = parent.domain

        // Mark domain as verified immediately (inherits from parent)
        await db
          .update(emailDomains)
          .set({
            status: "verified",
            verificationToken: null, // Not needed
            updatedAt: new Date(),
          })
          .where(eq(emailDomains.id, domainRecord.id))

        // Save the MX record to database so it shows in DNS records
        const mxRecordValue = `10 inbound-smtp.${awsRegion}.amazonaws.com`
        await db.insert(domainDnsRecords).values({
          id: `dns_${nanoid()}`,
          domainId: domainRecord.id,
          recordType: "MX",
          name: domain,
          value: mxRecordValue,
          isRequired: true,
          isVerified: false,
          createdAt: new Date(),
        })
        console.log(`üíæ Saved MX record to database for subdomain: ${domain}`)

        // Return simplified response with only MX record
        const response = {
          id: domainRecord.id,
          domain: domainRecord.domain,
          status: "verified" as const,
          canReceiveEmails: domainRecord.canReceiveEmails || false,
          hasMxRecords: domainRecord.hasMxRecords || false,
          domainProvider: domainRecord.domainProvider,
          providerConfidence: domainRecord.providerConfidence,
          dnsRecords: [
            {
              type: "MX",
              name: domain,
              value: mxRecordValue,
              description: "Add this MX record to receive emails at this subdomain",
              isRequired: true,
            },
          ],
          dnsConflict,
          createdAt: domainRecord.createdAt || new Date(),
          updatedAt: new Date(),
          parentDomain: parent.domain,
          message: dnsConflict 
            ? `Subdomain inherits verification from ${parent.domain}. Note: ${dnsConflict.message}`
            : `Subdomain inherits verification from ${parent.domain}. Only MX record needed for receiving.`,
        }

        console.log(
          `‚úÖ Subdomain created with parent verification: ${domain} inherits from ${parent.domain}`
        )
        set.status = 201
        return response
      }
    }

    // Initiate SES verification (includes tenant association for new domains)
    console.log("üîê Initiating SES domain verification with tenant integration")
    const verificationResult = await initiateDomainVerification(domain, userId)

    // Track domain usage with Autumn (only if not unlimited)
    if (!domainCheck.unlimited) {
      console.log("üìä Tracking domain usage with Autumn")
      const { error: trackError } = await autumn.track({
        customer_id: userId,
        feature_id: "domains",
        value: 1,
      })

      if (trackError) {
        console.error("‚ö†Ô∏è Failed to track domain usage:", trackError)
        // Don't fail the request, just log the warning
      }
    }

    // Format response
    const response = {
      id: domainRecord.id,
      domain: domainRecord.domain,
      status: verificationResult.status as "pending" | "verified" | "failed",
      canReceiveEmails: domainRecord.canReceiveEmails || false,
      hasMxRecords: domainRecord.hasMxRecords || false,
      domainProvider: domainRecord.domainProvider,
      providerConfidence: domainRecord.providerConfidence,
      mailFromDomain: verificationResult.mailFromDomain,
      mailFromDomainStatus: verificationResult.mailFromDomainStatus,
      dnsRecords: verificationResult.dnsRecords.map((record) => ({
        type: record.type,
        name: record.name,
        value: record.value,
        description: record.description,
        isRequired: true,
      })),
      dnsConflict,
      createdAt: domainRecord.createdAt || new Date(),
      updatedAt: domainRecord.updatedAt || new Date(),
      message: dnsConflict 
        ? `Domain created with DNS conflict warning: ${dnsConflict.message}`
        : undefined,
    }

    console.log("‚úÖ Successfully created domain:", domainRecord.id)
    set.status = 201
    return response
  },
  {
    body: CreateDomainBody,
    response: t.Union([CreateDomainResponse, CreateDomainErrorResponse]),
    detail: {
      tags: ["Domains"],
      summary: "Create new domain",
      description:
        "Add a new domain for email receiving. Automatically initiates SES verification and returns required DNS records.",
    },
  }
)
